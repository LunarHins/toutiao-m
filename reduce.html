
<!DOCTYPE html>
<html lang="">
    <head>
       <script>
        //reduce方法 是一个对数组中的每个元素执行一个
        // reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，
        // 将其结果汇总为单个返回值。
        // 1.数组
//         const arr1 = [1,3,4,6];
//         // // 2.reducer函数
//         const reducer = (acc,cur,ind) => acc+cur;
        
//         // // 3.使用reduce方法
//         console.log(arr1.reduce(reducer));

//         //定义一个reducer函数，
//         var maxCallback = ( acc, cur ) => Math.max( acc.x, cur.x );
//         var maxCallback2 = ( max, cur ) => Math.max( max, cur );

// // reduce() 没有初始值
// [ { x: 2 }, { x: 22 }, { x: 42 } ].reduce( maxCallback ); // NaN
// [ { x: 2 }, { x: 22 }            ].reduce( maxCallback ); // 22
// [ { x: 2 }                       ].reduce( maxCallback ); // { x: 2 }
// // [                                ].reduce( maxCallback ); // TypeError

// // // map/reduce; 提供一个initialValue，这是更好的方案，
// // 即使传入空数组或更大数组也可正常执行
// const abc = [ { x: 22 }, { x: 42 } ].map( el => el.x ).reduce( maxCallback2, -Infinity );
// console.log(abc);

// //最基本reduce方法
// var x = [1,5,9,4].reduce(function(acc,cur,ind,arr){
//     // 箭头函数代替： [1,5,9,4].reduce((acc,cur) => acc+cur)
//     return acc + cur;
// });
// console.log(x);

// 'use strict';
// // 求和方法
// function sum(...rest) {
//     //尽量给定初始值initialValue,数字类型就给数字类型？
//     // 数组就给数组？
//    return rest.reduce((acc,cur) => acc+cur,0);
// }
// // 测试:
// // 定义一个变量i，一个数组args
// var i, args = [];
// //执行一个循环，当
// for (i=1; i<=100; i++) {
//     args.push(i);
// }
// console.log(args);
// console.log(sum()!==0&&true);
// console.log(sum(2,3));//没有传递参数，等于0

// if (sum() !== 0) {
//     console.log('测试失败: sum() = ' + sum());
// } else if (sum(1) !== 1) {
//     console.log('测试失败: sum(1) = ' + sum(1));
// } else if (sum(2, 3) !== 5) {
//     console.log('测试失败: sum(2, 3) = ' + sum(2, 3));
// } else if (sum.apply(null, args) !== 5050) {
//     console.log('测试失败: sum(1, 2, 3, ..., 100) = ' + sum.apply(null, args));
// } else {
//     console.log('测试通过!');
// }

// // 将二维数组转化为一维,还要给定一个空数组作为初始值。
// var flattened = [[1,3],[3,5],[5,3]].reduce(function(a,b){
//   return a.concat(b);
// },[]);
// var f1 = [[1,3],[3,5],[5,3]];
// // console.log(f1);
// f1.reduce(function(a,b){
//   // console.log(a)

//   // console.log(b)

//   return a.concat(b);
// },[]);
// console.log(flattened);
// console.log(f1);

// 计算数组中每个元素出现的次数
//定义一个数组
// var names = ['Alice', 'Bob', 'Tiff', 'Bruce', 'Alice'];
// var countedNames = names.reduce(function (allNames, name,ind,names) { 
// // 定义一个方法，方法有两个参数，
//   //判断当前值名字name是否存在于计数器累计器 allNanmes中。
//   // console.log(allNames)
//   // console.log(name)
//   // console.log(allNames[name])
//   if (name in allNames) {
//     //如果存在，则 ++
//     console.log(allNames[name])
//     console.log(allNames)
//     allNames[name]++;
//     // console.log(allNames)
//   }
//   else {
//     allNames[name] = 1;
//   }
//   return allNames;
// },{});
// console.log(countedNames)

// 按属性对object分类，
// object 数组对象
// var people = [
//   {name:"alice",age:55},
//   {name:'man',age:16},
//   {name:'hali',age:18},
//   {name:'gg',age:18}

// ]
// console.log(people[0].age);

// //方法
// reduce是数组的方法。reduce对数组的每个元素执行一个由你提供的reducer函数
// 。升序执行。返回值，其结果汇总成单个返回值。
//   //对数组objectArray进行reduce操作，执行我们给定的函数，
//   //目的，分类出属性property。
//   //根据属性age对应放入当前值obj。
//   //
//直接调用reduce方法，返回的是单个结果值。
// 通过定义一个方法，传递参数，才能完成。
//总之就是把数组里面的每一项都传给了 cur
// function groupBy(arr,porperty){
//   return arr.reduce(function(acc,cur){
    // return console.log(x);
    //如何得到年龄
    // 通过索引访问数组元素。
    // // console.log(people[0].age);
// console.log(cur[porperty]);

    // var key = cur[porperty];
// console.log(key);
// 累计器当前尚未定义。
// acc = cur;
//要得到的是
// age:[
//   {name:'alice',age:20},
// {name:'alice',age:20},
// {name:'alice',age:20}
// ]
//返回的是acc

// var key = cur[porperty];
// if(!acc[key]){
//   acc[key] = [];
// }
// acc[key].push(cur);
// return acc;

//   },{});


//   // return arr;
// }


// var x = groupBy(people,'age');
// console.log(x);



// //设置一个key，当前值[属性]   数组的下标 arr[0]

// //然后比较acc的[key]
// //到这一步，取出了 属性age的值。剩下age的值对应的name值。
// //取反，为啥要取反


// //为了进入判断,acc[key]为undefined，则!acc[key]为true。进入判断。


//   //如果acc[key]未定义，则把空数组赋值给他。



//     // 把obj数组的值push进acc[key]中








// //直接调用方法，按照属性age对数组people分类,




// 使用扩展运算符和initialValue绑定包含在对象数组中的数组

// friends - 对象数组
var friends = [
  {name:'jan',books:['halo','janm'],age:41},
  {name:'tjjh',books:['uyo','nmnm'],age:34},
  {name:'bfert',books:['asdf','werew'],age:51},
  {name:'logb',books:['badsf','cc'],age:7},

]
// //解构赋值，分别取出赋值。数组才是可迭代数据，这个应该是展开语法

var allbooks = friends.reduce(function(acc,cur){
  //存到acc里面才是 累计器，显示最终的数组，在cur的只是单个数值。
  // 返回的是一个数组，展开语法。
  //展开语法(Spread syntax), 可以在函数调用数组构造时, 将数组表达式或者string在语法层面展开；
  // 还可以在构造字面量对象时, 将对象表达式按key-value的方式展开。
  // (译者注: 字面量一般指 [1, 2, 3] 或者 {name: "mdn"} 这种简洁的构造方式)
//   使用展开语法:
// var arr1 = [0, 1, 2];
// var arr2 = [3, 4, 5];
// var arr3 = [...arr1, ...arr2];
// arr3 现在是 [3, 4, 5, 0, 1, 2]

//使用展开语法，可以看作把[acc]累计器和[cur.books]当作数组
return [...acc,...cur.books];

},['shu'])
console.log(allbooks);



       </script>
    </head>
    <body>
       
    </body>
</html>
